{"ast":null,"code":"import _toConsumableArray from \"/Users/chandnipatel/Desktop/GitHub Forks/Jotai-TicTac/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/chandnipatel/Desktop/GitHub Forks/Jotai-TicTac/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/chandnipatel/Desktop/GitHub Forks/Jotai-TicTac/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport React, { useRef, useState, useMemo, useEffect, createElement, useDebugValue, useCallback } from 'react';\nimport { createContext, useContextUpdate, useContext, useContextSelector, useBridgeValue, BridgeProvider } from 'use-context-selector';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar createState = function createState(initialValues) {\n  var state = {\n    a: new WeakMap(),\n    m: new Map(),\n    w: new Map()\n  };\n\n  if (initialValues) {\n    var _iterator = _createForOfIteratorHelper(initialValues),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            _atom = _step$value[0],\n            value = _step$value[1];\n\n        var atomState = {\n          v: value,\n          r: 0,\n          d: new Map()\n        };\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          Object.freeze(atomState);\n        }\n\n        state.a.set(_atom, atomState);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return state;\n};\n\nvar getAtomState = function getAtomState(state, atom) {\n  return state.w.get(atom) || state.a.get(atom);\n};\n\nvar copyWip = function copyWip(state, copyingState) {\n  return _extends({}, state, {\n    w: new Map([].concat(_toConsumableArray(state.w), _toConsumableArray(copyingState.w)))\n  });\n};\n\nvar wipAtomState = function wipAtomState(state, atom) {\n  var atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState = _extends({}, atomState); // copy\n  } else {\n    atomState = {\n      r: 0,\n      d: new Map()\n    };\n\n    if (hasInitialValue(atom)) {\n      atomState.v = atom.init;\n    }\n  }\n\n  var nextState = _extends({}, state, {\n    w: new Map(state.w).set(atom, atomState)\n  });\n\n  return [atomState, nextState];\n};\n\nvar replaceDependencies = function replaceDependencies(state, atomState, dependencies) {\n  if (dependencies) {\n    atomState.d = new Map(Array.from(dependencies).map(function (a) {\n      var _getAtomState$r, _getAtomState;\n\n      return [a, (_getAtomState$r = (_getAtomState = getAtomState(state, a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n    }));\n  }\n};\n\nvar setAtomValue = function setAtomValue(state, atom, value, dependencies, promise) {\n  var _wipAtomState = wipAtomState(state, atom),\n      _wipAtomState2 = _slicedToArray(_wipAtomState, 2),\n      atomState = _wipAtomState2[0],\n      nextState = _wipAtomState2[1];\n\n  if (promise && promise !== atomState.rp) {\n    return state;\n  }\n\n  delete atomState.re;\n  delete atomState.rp;\n\n  if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n    atomState.v = value;\n    atomState.r++;\n  }\n\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nvar setAtomReadError = function setAtomReadError(state, atom, error, dependencies, promise) {\n  var _wipAtomState3 = wipAtomState(state, atom),\n      _wipAtomState4 = _slicedToArray(_wipAtomState3, 2),\n      atomState = _wipAtomState4[0],\n      nextState = _wipAtomState4[1];\n\n  if (promise && promise !== atomState.rp) {\n    return state;\n  }\n\n  delete atomState.rp;\n  atomState.re = error;\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nvar setAtomReadPromise = function setAtomReadPromise(state, atom, promise, dependencies) {\n  var _wipAtomState5 = wipAtomState(state, atom),\n      _wipAtomState6 = _slicedToArray(_wipAtomState5, 2),\n      atomState = _wipAtomState6[0],\n      nextState = _wipAtomState6[1];\n\n  atomState.rp = promise;\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nvar setAtomWritePromise = function setAtomWritePromise(state, atom, promise) {\n  var _wipAtomState7 = wipAtomState(state, atom),\n      _wipAtomState8 = _slicedToArray(_wipAtomState7, 2),\n      atomState = _wipAtomState8[0],\n      nextState = _wipAtomState8[1];\n\n  if (promise) {\n    atomState.wp = promise;\n  } else {\n    delete atomState.wp;\n  }\n\n  return nextState;\n};\n\nvar readAtomState = function readAtomState(state, updateState, atom, force) {\n  if (!force) {\n    var atomState = getAtomState(state, atom);\n\n    if (atomState && Array.from(atomState.d.entries()).every(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          a = _ref2[0],\n          r = _ref2[1];\n\n      var aState = getAtomState(state, a);\n      return aState && !aState.re && !aState.rp && aState.r === r;\n    })) {\n      return [atomState, state];\n    }\n  }\n\n  var asyncState = _extends({}, state, {\n    w: new Map()\n  }); // empty wip\n\n\n  var isSync = true;\n  var nextState = state;\n  var error;\n  var promise;\n  var value;\n  var dependencies = new Set();\n\n  try {\n    var promiseOrValue = atom.read(function (a) {\n      dependencies.add(a);\n\n      if (a !== atom) {\n        var _aState;\n\n        if (isSync) {\n          ;\n\n          var _readAtomState = readAtomState(nextState, updateState, a);\n\n          var _readAtomState2 = _slicedToArray(_readAtomState, 2);\n\n          _aState = _readAtomState2[0];\n          nextState = _readAtomState2[1];\n        } else {\n          ;\n\n          var _readAtomState3 = readAtomState(asyncState, updateState, a);\n\n          var _readAtomState4 = _slicedToArray(_readAtomState3, 2);\n\n          _aState = _readAtomState4[0];\n          asyncState = _readAtomState4[1];\n        }\n\n        if (_aState.re) {\n          throw _aState.re; // read error\n        }\n\n        if (_aState.rp) {\n          throw _aState.rp; // read promise\n        }\n\n        return _aState.v; // value\n      } // a === atom\n\n\n      var aState = getAtomState(nextState, a);\n\n      if (aState) {\n        if (aState.rp) {\n          throw aState.rp; // read promise\n        }\n\n        return aState.v; // value\n      }\n\n      if (hasInitialValue(a)) {\n        return a.init;\n      }\n\n      throw new Error('no atom init');\n    });\n\n    if (promiseOrValue instanceof Promise) {\n      promise = promiseOrValue.then(function (value) {\n        updateState(function (prev) {\n          return setAtomValue(copyWip(prev, asyncState), atom, value, dependencies, promise);\n        });\n      }).catch(function (e) {\n        updateState(function (prev) {\n          return setAtomReadError(copyWip(prev, asyncState), atom, e instanceof Error ? e : new Error(e), dependencies, promise);\n        });\n      });\n    } else {\n      value = promiseOrValue;\n    }\n  } catch (errorOrPromise) {\n    if (errorOrPromise instanceof Promise) {\n      promise = errorOrPromise.then(function () {\n        updateState(function (prev) {\n          var _readAtomState5 = readAtomState(prev, updateState, atom, true),\n              _readAtomState6 = _slicedToArray(_readAtomState5, 2),\n              nextNextState = _readAtomState6[1];\n\n          if (nextNextState.w.size) {\n            return nextNextState;\n          }\n\n          return prev;\n        });\n      });\n    } else if (errorOrPromise instanceof Error) {\n      error = errorOrPromise;\n    } else {\n      error = new Error(errorOrPromise);\n    }\n  }\n\n  if (error) {\n    nextState = setAtomReadError(nextState, atom, error, dependencies);\n  } else if (promise) {\n    nextState = setAtomReadPromise(nextState, atom, promise, dependencies);\n  } else {\n    nextState = setAtomValue(nextState, atom, value, dependencies);\n  }\n\n  isSync = false;\n  return [getAtomState(nextState, atom), nextState];\n};\n\nvar readAtom = function readAtom(state, updateState, readingAtom) {\n  var _readAtomState7 = readAtomState(state, updateState, readingAtom),\n      _readAtomState8 = _slicedToArray(_readAtomState7, 2),\n      atomState = _readAtomState8[0],\n      nextState = _readAtomState8[1]; // merge back wip\n\n\n  nextState.w.forEach(function (atomState, atom) {\n    state.w.set(atom, atomState);\n  });\n  return atomState;\n};\n\nvar addAtom = function addAtom(state, updateState, addingAtom, useId) {\n  var mounted = state.m.get(addingAtom);\n\n  if (mounted) {\n    var _mounted = _slicedToArray(mounted, 1),\n        dependents = _mounted[0];\n\n    dependents.add(useId);\n  } else {\n    mountAtom(state, updateState, addingAtom, useId);\n  }\n}; // XXX doesn't work with mutally dependent atoms\n\n\nvar canUnmountAtom = function canUnmountAtom(atom, dependents) {\n  return !dependents.size || dependents.size === 1 && dependents.has(atom);\n};\n\nvar delAtom = function delAtom(state, deletingAtom, useId) {\n  var mounted = state.m.get(deletingAtom);\n\n  if (mounted) {\n    var _mounted2 = _slicedToArray(mounted, 1),\n        dependents = _mounted2[0];\n\n    dependents.delete(useId);\n\n    if (canUnmountAtom(deletingAtom, dependents)) {\n      unmountAtom(state, deletingAtom);\n    }\n  }\n};\n\nvar getDependents = function getDependents(state, atom) {\n  var mounted = state.m.get(atom);\n  var dependents = new Set(mounted == null ? void 0 : mounted[0]); // collecting from wip\n\n  state.w.forEach(function (aState, a) {\n    if (aState.d.has(atom)) {\n      dependents.add(a);\n    }\n  });\n  return dependents;\n};\n\nvar updateDependentsState = function updateDependentsState(state, updateState, atom, prevAtomState) {\n  var _getAtomState2;\n\n  if (!prevAtomState || prevAtomState.r === ((_getAtomState2 = getAtomState(state, atom)) == null ? void 0 : _getAtomState2.r)) {\n    return state; // bail out\n  }\n\n  var dependents = getDependents(state, atom);\n  var nextState = state;\n  dependents.forEach(function (dependent) {\n    if (dependent === atom || typeof dependent === 'symbol') {\n      return;\n    }\n\n    var dependentState = getAtomState(nextState, dependent);\n\n    var _readAtomState9 = readAtomState(nextState, updateState, dependent, true),\n        _readAtomState10 = _slicedToArray(_readAtomState9, 2),\n        nextDependentState = _readAtomState10[0],\n        nextNextState = _readAtomState10[1];\n\n    var promise = nextDependentState.rp;\n\n    if (promise) {\n      promise.then(function () {\n        updateState(function (prev) {\n          return updateDependentsState(prev, updateState, dependent, dependentState);\n        });\n      });\n      nextState = nextNextState;\n    } else {\n      nextState = updateDependentsState(nextNextState, updateState, dependent, dependentState);\n    }\n  });\n  return nextState;\n};\n\nvar writeAtomState = function writeAtomState(state, updateState, atom, update, pendingPromises) {\n  var atomState = getAtomState(state, atom);\n\n  if (atomState && atomState.wp) {\n    var promise = atomState.wp.then(function () {\n      updateState(function (prev) {\n        return writeAtomState(prev, updateState, atom, update);\n      });\n    });\n\n    if (pendingPromises) {\n      pendingPromises.push(promise);\n    }\n\n    return state;\n  }\n\n  var nextState = state;\n  var isSync = true;\n\n  try {\n    var promiseOrVoid = atom.write(function (a) {\n      var aState = getAtomState(nextState, a);\n\n      if (!aState) {\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('Unable to read an atom without initial value in write function. Please useAtom in advance.', a);\n        }\n\n        throw new Error('uninitialized atom');\n      }\n\n      if (aState.rp && typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        // TODO will try to detect this\n        console.warn('Reading pending atom state in write operation. We need to detect this and fallback. Please file an issue with repro.', a);\n      }\n\n      return aState.v;\n    }, function (a, v) {\n      if (a === atom) {\n        var aState = getAtomState(nextState, a);\n\n        if (isSync) {\n          nextState = updateDependentsState(setAtomValue(nextState, a, v), updateState, a, aState);\n        } else {\n          updateState(function (prev) {\n            return updateDependentsState(setAtomValue(prev, a, v), updateState, a, aState);\n          });\n        }\n      } else {\n        if (isSync) {\n          nextState = writeAtomState(nextState, updateState, a, v);\n        } else {\n          updateState(function (prev) {\n            return writeAtomState(prev, updateState, a, v);\n          });\n        }\n      }\n    }, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      if (pendingPromises) {\n        pendingPromises.push(promiseOrVoid);\n      }\n\n      nextState = setAtomWritePromise(nextState, atom, promiseOrVoid.then(function () {\n        updateState(function (prev) {\n          return setAtomWritePromise(prev, atom);\n        });\n      }));\n    }\n  } catch (e) {\n    if (pendingPromises && pendingPromises.length) {\n      pendingPromises.push(new Promise(function (_resolve, reject) {\n        reject(e);\n      }));\n    } else {\n      throw e;\n    }\n  }\n\n  isSync = false;\n  return nextState;\n};\n\nvar writeAtom = function writeAtom(updateState, writingAtom, update) {\n  var pendingPromises = [];\n  updateState(function (prev) {\n    var nextState = writeAtomState(prev, updateState, writingAtom, update, pendingPromises);\n    return nextState;\n  });\n\n  if (pendingPromises.length) {\n    return new Promise(function (resolve, reject) {\n      var loop = function loop() {\n        var len = pendingPromises.length;\n\n        if (len === 0) {\n          resolve();\n        } else {\n          Promise.all(pendingPromises).then(function () {\n            pendingPromises.splice(0, len);\n            loop();\n          }).catch(reject);\n        }\n      };\n\n      loop();\n    });\n  }\n};\n\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\n\nvar mountAtom = function mountAtom(state, updateState, atom, initialDependent) {\n  // mount dependencies beforehand\n  var atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        // check if not mounted\n        if (!state.m.has(a)) {\n          mountAtom(state, updateState, a, atom);\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to mount', atom);\n  } // mount self\n\n\n  var onUmount;\n\n  if (isActuallyWritableAtom(atom) && atom.onMount) {\n    var setAtom = function setAtom(update) {\n      return writeAtom(updateState, atom, update);\n    };\n\n    onUmount = atom.onMount(setAtom);\n  }\n\n  state.m.set(atom, [new Set([initialDependent]), onUmount]);\n};\n\nvar unmountAtom = function unmountAtom(state, atom) {\n  var _state$m$get; // unmount self\n\n\n  var onUnmount = (_state$m$get = state.m.get(atom)) == null ? void 0 : _state$m$get[1];\n\n  if (onUnmount) {\n    onUnmount();\n  }\n\n  state.m.delete(atom); // unmount dependencies afterward\n\n  var atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    if (atomState.rp && typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] deleting atomState with read promise', atom);\n    }\n\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var _state$m$get2;\n\n        var dependents = (_state$m$get2 = state.m.get(a)) == null ? void 0 : _state$m$get2[0];\n\n        if (dependents) {\n          dependents.delete(atom);\n\n          if (canUnmountAtom(a, dependents)) {\n            unmountAtom(state, a);\n          }\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to unmount', atom);\n  }\n};\n\nvar commitState = function commitState(state, updateState) {\n  if (state.w.size) {\n    // apply wip to MountedMap\n    state.w.forEach(function (atomState, atom) {\n      var _state$a$get;\n\n      var prevDependencies = (_state$a$get = state.a.get(atom)) == null ? void 0 : _state$a$get.d;\n\n      if (prevDependencies === atomState.d) {\n        return;\n      }\n\n      var dependencies = new Set(atomState.d.keys());\n\n      if (prevDependencies) {\n        prevDependencies.forEach(function (_, a) {\n          var mounted = state.m.get(a);\n\n          if (dependencies.has(a)) {\n            // not changed\n            dependencies.delete(a);\n          } else if (mounted) {\n            var _mounted3 = _slicedToArray(mounted, 1),\n                dependents = _mounted3[0];\n\n            dependents.delete(atom);\n\n            if (canUnmountAtom(a, dependents)) {\n              unmountAtom(state, a);\n            }\n          } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n            console.warn('[Bug] a dependency is not mounted', a);\n          }\n        });\n      }\n\n      dependencies.forEach(function (a) {\n        var mounted = state.m.get(a);\n\n        if (mounted) {\n          var _mounted4 = _slicedToArray(mounted, 1),\n              dependents = _mounted4[0];\n\n          dependents.add(atom);\n        } else {\n          mountAtom(state, updateState, a, atom);\n        }\n      });\n    }); // copy wip to AtomStateMap\n\n    state.w.forEach(function (atomState, atom) {\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n      }\n\n      state.a.set(atom, atomState);\n    }); // empty wip\n\n    state.w.clear();\n  }\n};\n\nvar ContextsMap = new Map();\n\nvar getContexts = function getContexts(scope) {\n  if (!ContextsMap.has(scope)) {\n    ContextsMap.set(scope, [createContext(null), createContext(null)]);\n  }\n\n  return ContextsMap.get(scope);\n};\n\nvar isReactExperimental = !!(typeof process === 'object' && process.env.IS_REACT_EXPERIMENTAL) || !!React.unstable_useMutableSource;\n\nvar defaultContextUpdate = function defaultContextUpdate(f) {\n  return f();\n};\n\nvar InnerProvider = function InnerProvider(_ref3) {\n  var r = _ref3.r,\n      c = _ref3.c,\n      children = _ref3.children;\n  var contextUpdate = useContextUpdate(c);\n\n  if (isReactExperimental && r.current === defaultContextUpdate) {\n    r.current = function (f) {\n      return contextUpdate(f);\n    };\n  }\n\n  return children != null ? children : null;\n};\n\nvar Provider = function Provider(_ref4) {\n  var initialValues = _ref4.initialValues,\n      scope = _ref4.scope,\n      children = _ref4.children;\n  var contextUpdateRef = useRef(defaultContextUpdate);\n\n  var _useState = useState(function () {\n    return createState(initialValues);\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var lastStateRef = useRef(state);\n  var updateState = useMemo(function () {\n    var queue = [];\n    return function (updater) {\n      queue.push(updater);\n\n      if (queue.length > 1) {\n        return;\n      }\n\n      while (queue.length) {\n        lastStateRef.current = queue[0](lastStateRef.current);\n        queue.shift();\n      }\n\n      contextUpdateRef.current(function () {\n        setState(lastStateRef.current);\n      });\n    };\n  }, []);\n  useEffect(function () {\n    commitState(state, updateState);\n    lastStateRef.current = state;\n  });\n  var actions = useMemo(function () {\n    return {\n      add: function add(atom, id) {\n        addAtom(lastStateRef.current, updateState, atom, id);\n      },\n      del: function del(atom, id) {\n        delAtom(lastStateRef.current, atom, id);\n      },\n      read: function read(state, atom) {\n        return readAtom(state, updateState, atom);\n      },\n      write: function write(atom, update) {\n        return writeAtom(updateState, atom, update);\n      }\n    };\n  }, [updateState]);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugState(state);\n  }\n\n  var _getContexts = getContexts(scope),\n      _getContexts2 = _slicedToArray(_getContexts, 2),\n      ActionsContext = _getContexts2[0],\n      StateContext = _getContexts2[1];\n\n  return createElement(ActionsContext.Provider, {\n    value: actions\n  }, createElement(StateContext.Provider, {\n    value: state\n  }, createElement(InnerProvider, {\n    r: contextUpdateRef,\n    c: StateContext\n  }, children)));\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar isAtom = function isAtom(x) {\n  return typeof x !== 'symbol';\n};\n\nvar stateToPrintable = function stateToPrintable(state) {\n  return Object.fromEntries(Array.from(state.m.entries()).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        atom = _ref6[0],\n        _ref6$ = _slicedToArray(_ref6[1], 1),\n        dependents = _ref6$[0];\n\n    var atomState = state.a.get(atom) || {};\n    return [atomToPrintable(atom), {\n      value: atomState.re || atomState.rp || atomState.wp || atomState.v,\n      dependents: Array.from(dependents).filter(isAtom).map(atomToPrintable)\n    }];\n  }));\n};\n\nvar useDebugState = function useDebugState(state) {\n  useDebugValue(state, stateToPrintable);\n};\n\nvar keyCount = 0; // global key count for all atoms\n\nfunction atom(read, write) {\n  var key = \"atom\".concat(++keyCount);\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nfunction assertContextValue(x, scope) {\n  if (!x) {\n    throw new Error(\"Please use <Provider\".concat(scope ? \" scope=\".concat(String(scope)) : '', \">\"));\n  }\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom) {\n  var _getContexts3 = getContexts(atom.scope),\n      _getContexts4 = _slicedToArray(_getContexts3, 2),\n      ActionsContext = _getContexts4[0],\n      StateContext = _getContexts4[1];\n\n  var actions = useContext(ActionsContext);\n  assertContextValue(actions, atom.scope);\n  var value = useContextSelector(StateContext, useCallback(function (state) {\n    assertContextValue(state);\n    var atomState = actions.read(state, atom);\n\n    if (atomState.re) {\n      throw atomState.re; // read error\n    }\n\n    if (atomState.rp) {\n      throw atomState.rp; // read promise\n    }\n\n    if (atomState.wp) {\n      throw atomState.wp; // write promise\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [atom, actions]));\n  useEffect(function () {\n    var id = Symbol();\n    actions.add(atom, id);\n    return function () {\n      actions.del(atom, id);\n    };\n  }, [actions, atom]);\n  var setAtom = useCallback(function (update) {\n    if (isWritable(atom)) {\n      return actions.write(atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [atom, actions]);\n  useDebugValue(value);\n  return [value, setAtom];\n}\n\nvar useBridge = function useBridge(scope) {\n  var _getContexts5 = getContexts(scope),\n      _getContexts6 = _slicedToArray(_getContexts5, 2),\n      ActionsContext = _getContexts6[0],\n      StateContext = _getContexts6[1];\n\n  var actions = useBridgeValue(ActionsContext);\n  var state = useBridgeValue(StateContext);\n  return useMemo(function () {\n    return [actions, state];\n  }, [actions, state]);\n};\n\nvar Bridge = function Bridge(_ref7) {\n  var value = _ref7.value,\n      scope = _ref7.scope,\n      children = _ref7.children;\n\n  var _value = _slicedToArray(value, 2),\n      actions = _value[0],\n      state = _value[1];\n\n  var _getContexts7 = getContexts(scope),\n      _getContexts8 = _slicedToArray(_getContexts7, 2),\n      ActionsContext = _getContexts8[0],\n      StateContext = _getContexts8[1];\n\n  return createElement(BridgeProvider, {\n    context: ActionsContext,\n    value: actions\n  }, createElement(BridgeProvider, {\n    context: StateContext,\n    value: state\n  }, children));\n};\n\nexport { Bridge, Provider, atom, useAtom, useBridge };","map":{"version":3,"sources":["/Users/chandnipatel/Desktop/GitHub Forks/Jotai-TicTac/node_modules/jotai/index.module.js"],"names":["React","useRef","useState","useMemo","useEffect","createElement","useDebugValue","useCallback","createContext","useContextUpdate","useContext","useContextSelector","useBridgeValue","BridgeProvider","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","hasInitialValue","atom","createState","initialValues","state","a","WeakMap","m","Map","w","value","atomState","v","r","d","process","env","NODE_ENV","freeze","set","getAtomState","get","copyWip","copyingState","wipAtomState","init","nextState","replaceDependencies","dependencies","Array","from","map","_getAtomState$r","_getAtomState","setAtomValue","promise","rp","re","is","setAtomReadError","error","setAtomReadPromise","setAtomWritePromise","wp","readAtomState","updateState","force","entries","every","aState","asyncState","isSync","Set","promiseOrValue","read","add","Error","Promise","then","prev","catch","e","errorOrPromise","nextNextState","size","readAtom","readingAtom","forEach","addAtom","addingAtom","useId","mounted","dependents","mountAtom","canUnmountAtom","has","delAtom","deletingAtom","delete","unmountAtom","getDependents","updateDependentsState","prevAtomState","_getAtomState2","dependent","dependentState","nextDependentState","writeAtomState","update","pendingPromises","push","promiseOrVoid","write","console","warn","_resolve","reject","writeAtom","writingAtom","resolve","loop","len","all","splice","isActuallyWritableAtom","initialDependent","_","onUmount","onMount","setAtom","_state$m$get","onUnmount","_state$m$get2","commitState","_state$a$get","prevDependencies","keys","clear","ContextsMap","getContexts","scope","isReactExperimental","IS_REACT_EXPERIMENTAL","unstable_useMutableSource","defaultContextUpdate","f","InnerProvider","c","children","contextUpdate","current","Provider","contextUpdateRef","setState","lastStateRef","queue","updater","shift","actions","id","del","useDebugState","ActionsContext","StateContext","atomToPrintable","debugLabel","toString","isAtom","x","stateToPrintable","fromEntries","filter","keyCount","config","assertContextValue","String","isWritable","useAtom","Symbol","useBridge","Bridge","context"],"mappings":"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","sourcesContent":["import React, { useRef, useState, useMemo, useEffect, createElement, useDebugValue, useCallback } from 'react';\nimport { createContext, useContextUpdate, useContext, useContextSelector, useBridgeValue, BridgeProvider } from 'use-context-selector';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst hasInitialValue = atom => 'init' in atom;\n\nconst createState = initialValues => {\n  const state = {\n    a: new WeakMap(),\n    m: new Map(),\n    w: new Map()\n  };\n\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n      }\n\n      state.a.set(atom, atomState);\n    }\n  }\n\n  return state;\n};\n\nconst getAtomState = (state, atom) => state.w.get(atom) || state.a.get(atom);\n\nconst copyWip = (state, copyingState) => _extends({}, state, {\n  w: new Map([...state.w, ...copyingState.w])\n});\n\nconst wipAtomState = (state, atom) => {\n  let atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState = _extends({}, atomState); // copy\n  } else {\n    atomState = {\n      r: 0,\n      d: new Map()\n    };\n\n    if (hasInitialValue(atom)) {\n      atomState.v = atom.init;\n    }\n  }\n\n  const nextState = _extends({}, state, {\n    w: new Map(state.w).set(atom, atomState)\n  });\n\n  return [atomState, nextState];\n};\n\nconst replaceDependencies = (state, atomState, dependencies) => {\n  if (dependencies) {\n    atomState.d = new Map(Array.from(dependencies).map(a => {\n      var _getAtomState$r, _getAtomState;\n\n      return [a, (_getAtomState$r = (_getAtomState = getAtomState(state, a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n    }));\n  }\n};\n\nconst setAtomValue = (state, atom, value, dependencies, promise) => {\n  const [atomState, nextState] = wipAtomState(state, atom);\n\n  if (promise && promise !== atomState.rp) {\n    return state;\n  }\n\n  delete atomState.re;\n  delete atomState.rp;\n\n  if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n    atomState.v = value;\n    atomState.r++;\n  }\n\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nconst setAtomReadError = (state, atom, error, dependencies, promise) => {\n  const [atomState, nextState] = wipAtomState(state, atom);\n\n  if (promise && promise !== atomState.rp) {\n    return state;\n  }\n\n  delete atomState.rp;\n  atomState.re = error;\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nconst setAtomReadPromise = (state, atom, promise, dependencies) => {\n  const [atomState, nextState] = wipAtomState(state, atom);\n  atomState.rp = promise;\n  replaceDependencies(nextState, atomState, dependencies);\n  return nextState;\n};\n\nconst setAtomWritePromise = (state, atom, promise) => {\n  const [atomState, nextState] = wipAtomState(state, atom);\n\n  if (promise) {\n    atomState.wp = promise;\n  } else {\n    delete atomState.wp;\n  }\n\n  return nextState;\n};\n\nconst readAtomState = (state, updateState, atom, force) => {\n  if (!force) {\n    const atomState = getAtomState(state, atom);\n\n    if (atomState && Array.from(atomState.d.entries()).every(([a, r]) => {\n      const aState = getAtomState(state, a);\n      return aState && !aState.re && !aState.rp && aState.r === r;\n    })) {\n      return [atomState, state];\n    }\n  }\n\n  let asyncState = _extends({}, state, {\n    w: new Map()\n  }); // empty wip\n\n\n  let isSync = true;\n  let nextState = state;\n  let error;\n  let promise;\n  let value;\n  const dependencies = new Set();\n\n  try {\n    const promiseOrValue = atom.read(a => {\n      dependencies.add(a);\n\n      if (a !== atom) {\n        let aState;\n\n        if (isSync) {\n          ;\n          [aState, nextState] = readAtomState(nextState, updateState, a);\n        } else {\n          ;\n          [aState, asyncState] = readAtomState(asyncState, updateState, a);\n        }\n\n        if (aState.re) {\n          throw aState.re; // read error\n        }\n\n        if (aState.rp) {\n          throw aState.rp; // read promise\n        }\n\n        return aState.v; // value\n      } // a === atom\n\n\n      const aState = getAtomState(nextState, a);\n\n      if (aState) {\n        if (aState.rp) {\n          throw aState.rp; // read promise\n        }\n\n        return aState.v; // value\n      }\n\n      if (hasInitialValue(a)) {\n        return a.init;\n      }\n\n      throw new Error('no atom init');\n    });\n\n    if (promiseOrValue instanceof Promise) {\n      promise = promiseOrValue.then(value => {\n        updateState(prev => setAtomValue(copyWip(prev, asyncState), atom, value, dependencies, promise));\n      }).catch(e => {\n        updateState(prev => setAtomReadError(copyWip(prev, asyncState), atom, e instanceof Error ? e : new Error(e), dependencies, promise));\n      });\n    } else {\n      value = promiseOrValue;\n    }\n  } catch (errorOrPromise) {\n    if (errorOrPromise instanceof Promise) {\n      promise = errorOrPromise.then(() => {\n        updateState(prev => {\n          const [, nextNextState] = readAtomState(prev, updateState, atom, true);\n\n          if (nextNextState.w.size) {\n            return nextNextState;\n          }\n\n          return prev;\n        });\n      });\n    } else if (errorOrPromise instanceof Error) {\n      error = errorOrPromise;\n    } else {\n      error = new Error(errorOrPromise);\n    }\n  }\n\n  if (error) {\n    nextState = setAtomReadError(nextState, atom, error, dependencies);\n  } else if (promise) {\n    nextState = setAtomReadPromise(nextState, atom, promise, dependencies);\n  } else {\n    nextState = setAtomValue(nextState, atom, value, dependencies);\n  }\n\n  isSync = false;\n  return [getAtomState(nextState, atom), nextState];\n};\n\nconst readAtom = (state, updateState, readingAtom) => {\n  const [atomState, nextState] = readAtomState(state, updateState, readingAtom); // merge back wip\n\n  nextState.w.forEach((atomState, atom) => {\n    state.w.set(atom, atomState);\n  });\n  return atomState;\n};\nconst addAtom = (state, updateState, addingAtom, useId) => {\n  const mounted = state.m.get(addingAtom);\n\n  if (mounted) {\n    const [dependents] = mounted;\n    dependents.add(useId);\n  } else {\n    mountAtom(state, updateState, addingAtom, useId);\n  }\n}; // XXX doesn't work with mutally dependent atoms\n\nconst canUnmountAtom = (atom, dependents) => !dependents.size || dependents.size === 1 && dependents.has(atom);\n\nconst delAtom = (state, deletingAtom, useId) => {\n  const mounted = state.m.get(deletingAtom);\n\n  if (mounted) {\n    const [dependents] = mounted;\n    dependents.delete(useId);\n\n    if (canUnmountAtom(deletingAtom, dependents)) {\n      unmountAtom(state, deletingAtom);\n    }\n  }\n};\n\nconst getDependents = (state, atom) => {\n  const mounted = state.m.get(atom);\n  const dependents = new Set(mounted == null ? void 0 : mounted[0]); // collecting from wip\n\n  state.w.forEach((aState, a) => {\n    if (aState.d.has(atom)) {\n      dependents.add(a);\n    }\n  });\n  return dependents;\n};\n\nconst updateDependentsState = (state, updateState, atom, prevAtomState) => {\n  var _getAtomState2;\n\n  if (!prevAtomState || prevAtomState.r === ((_getAtomState2 = getAtomState(state, atom)) == null ? void 0 : _getAtomState2.r)) {\n    return state; // bail out\n  }\n\n  const dependents = getDependents(state, atom);\n  let nextState = state;\n  dependents.forEach(dependent => {\n    if (dependent === atom || typeof dependent === 'symbol') {\n      return;\n    }\n\n    const dependentState = getAtomState(nextState, dependent);\n    const [nextDependentState, nextNextState] = readAtomState(nextState, updateState, dependent, true);\n    const promise = nextDependentState.rp;\n\n    if (promise) {\n      promise.then(() => {\n        updateState(prev => updateDependentsState(prev, updateState, dependent, dependentState));\n      });\n      nextState = nextNextState;\n    } else {\n      nextState = updateDependentsState(nextNextState, updateState, dependent, dependentState);\n    }\n  });\n  return nextState;\n};\n\nconst writeAtomState = (state, updateState, atom, update, pendingPromises) => {\n  const atomState = getAtomState(state, atom);\n\n  if (atomState && atomState.wp) {\n    const promise = atomState.wp.then(() => {\n      updateState(prev => writeAtomState(prev, updateState, atom, update));\n    });\n\n    if (pendingPromises) {\n      pendingPromises.push(promise);\n    }\n\n    return state;\n  }\n\n  let nextState = state;\n  let isSync = true;\n\n  try {\n    const promiseOrVoid = atom.write(a => {\n      const aState = getAtomState(nextState, a);\n\n      if (!aState) {\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('Unable to read an atom without initial value in write function. Please useAtom in advance.', a);\n        }\n\n        throw new Error('uninitialized atom');\n      }\n\n      if (aState.rp && typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        // TODO will try to detect this\n        console.warn('Reading pending atom state in write operation. We need to detect this and fallback. Please file an issue with repro.', a);\n      }\n\n      return aState.v;\n    }, (a, v) => {\n      if (a === atom) {\n        const aState = getAtomState(nextState, a);\n\n        if (isSync) {\n          nextState = updateDependentsState(setAtomValue(nextState, a, v), updateState, a, aState);\n        } else {\n          updateState(prev => updateDependentsState(setAtomValue(prev, a, v), updateState, a, aState));\n        }\n      } else {\n        if (isSync) {\n          nextState = writeAtomState(nextState, updateState, a, v);\n        } else {\n          updateState(prev => writeAtomState(prev, updateState, a, v));\n        }\n      }\n    }, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      if (pendingPromises) {\n        pendingPromises.push(promiseOrVoid);\n      }\n\n      nextState = setAtomWritePromise(nextState, atom, promiseOrVoid.then(() => {\n        updateState(prev => setAtomWritePromise(prev, atom));\n      }));\n    }\n  } catch (e) {\n    if (pendingPromises && pendingPromises.length) {\n      pendingPromises.push(new Promise((_resolve, reject) => {\n        reject(e);\n      }));\n    } else {\n      throw e;\n    }\n  }\n\n  isSync = false;\n  return nextState;\n};\n\nconst writeAtom = (updateState, writingAtom, update) => {\n  const pendingPromises = [];\n  updateState(prev => {\n    const nextState = writeAtomState(prev, updateState, writingAtom, update, pendingPromises);\n    return nextState;\n  });\n\n  if (pendingPromises.length) {\n    return new Promise((resolve, reject) => {\n      const loop = () => {\n        const len = pendingPromises.length;\n\n        if (len === 0) {\n          resolve();\n        } else {\n          Promise.all(pendingPromises).then(() => {\n            pendingPromises.splice(0, len);\n            loop();\n          }).catch(reject);\n        }\n      };\n\n      loop();\n    });\n  }\n};\n\nconst isActuallyWritableAtom = atom => !!atom.write;\n\nconst mountAtom = (state, updateState, atom, initialDependent) => {\n  // mount dependencies beforehand\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        // check if not mounted\n        if (!state.m.has(a)) {\n          mountAtom(state, updateState, a, atom);\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to mount', atom);\n  } // mount self\n\n\n  let onUmount;\n\n  if (isActuallyWritableAtom(atom) && atom.onMount) {\n    const setAtom = update => writeAtom(updateState, atom, update);\n\n    onUmount = atom.onMount(setAtom);\n  }\n\n  state.m.set(atom, [new Set([initialDependent]), onUmount]);\n};\n\nconst unmountAtom = (state, atom) => {\n  var _state$m$get;\n\n  // unmount self\n  const onUnmount = (_state$m$get = state.m.get(atom)) == null ? void 0 : _state$m$get[1];\n\n  if (onUnmount) {\n    onUnmount();\n  }\n\n  state.m.delete(atom); // unmount dependencies afterward\n\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    if (atomState.rp && typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] deleting atomState with read promise', atom);\n    }\n\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        var _state$m$get2;\n\n        const dependents = (_state$m$get2 = state.m.get(a)) == null ? void 0 : _state$m$get2[0];\n\n        if (dependents) {\n          dependents.delete(atom);\n\n          if (canUnmountAtom(a, dependents)) {\n            unmountAtom(state, a);\n          }\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to unmount', atom);\n  }\n};\n\nconst commitState = (state, updateState) => {\n  if (state.w.size) {\n    // apply wip to MountedMap\n    state.w.forEach((atomState, atom) => {\n      var _state$a$get;\n\n      const prevDependencies = (_state$a$get = state.a.get(atom)) == null ? void 0 : _state$a$get.d;\n\n      if (prevDependencies === atomState.d) {\n        return;\n      }\n\n      const dependencies = new Set(atomState.d.keys());\n\n      if (prevDependencies) {\n        prevDependencies.forEach((_, a) => {\n          const mounted = state.m.get(a);\n\n          if (dependencies.has(a)) {\n            // not changed\n            dependencies.delete(a);\n          } else if (mounted) {\n            const [dependents] = mounted;\n            dependents.delete(atom);\n\n            if (canUnmountAtom(a, dependents)) {\n              unmountAtom(state, a);\n            }\n          } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n            console.warn('[Bug] a dependency is not mounted', a);\n          }\n        });\n      }\n\n      dependencies.forEach(a => {\n        const mounted = state.m.get(a);\n\n        if (mounted) {\n          const [dependents] = mounted;\n          dependents.add(atom);\n        } else {\n          mountAtom(state, updateState, a, atom);\n        }\n      });\n    }); // copy wip to AtomStateMap\n\n    state.w.forEach((atomState, atom) => {\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n      }\n\n      state.a.set(atom, atomState);\n    }); // empty wip\n\n    state.w.clear();\n  }\n};\n\nconst ContextsMap = new Map();\nconst getContexts = scope => {\n  if (!ContextsMap.has(scope)) {\n    ContextsMap.set(scope, [createContext(null), createContext(null)]);\n  }\n\n  return ContextsMap.get(scope);\n};\n\nconst isReactExperimental = !!(typeof process === 'object' && process.env.IS_REACT_EXPERIMENTAL) || !!React.unstable_useMutableSource;\n\nconst defaultContextUpdate = f => f();\n\nconst InnerProvider = ({\n  r,\n  c,\n  children\n}) => {\n  const contextUpdate = useContextUpdate(c);\n\n  if (isReactExperimental && r.current === defaultContextUpdate) {\n    r.current = f => contextUpdate(f);\n  }\n\n  return children != null ? children : null;\n};\n\nconst Provider = ({\n  initialValues,\n  scope,\n  children\n}) => {\n  const contextUpdateRef = useRef(defaultContextUpdate);\n  const [state, setState] = useState(() => createState(initialValues));\n  const lastStateRef = useRef(state);\n  const updateState = useMemo(() => {\n    const queue = [];\n    return updater => {\n      queue.push(updater);\n\n      if (queue.length > 1) {\n        return;\n      }\n\n      while (queue.length) {\n        lastStateRef.current = queue[0](lastStateRef.current);\n        queue.shift();\n      }\n\n      contextUpdateRef.current(() => {\n        setState(lastStateRef.current);\n      });\n    };\n  }, []);\n  useEffect(() => {\n    commitState(state, updateState);\n    lastStateRef.current = state;\n  });\n  const actions = useMemo(() => ({\n    add: (atom, id) => {\n      addAtom(lastStateRef.current, updateState, atom, id);\n    },\n    del: (atom, id) => {\n      delAtom(lastStateRef.current, atom, id);\n    },\n    read: (state, atom) => readAtom(state, updateState, atom),\n    write: (atom, update) => writeAtom(updateState, atom, update)\n  }), [updateState]);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugState(state);\n  }\n\n  const [ActionsContext, StateContext] = getContexts(scope);\n  return createElement(ActionsContext.Provider, {\n    value: actions\n  }, createElement(StateContext.Provider, {\n    value: state\n  }, createElement(InnerProvider, {\n    r: contextUpdateRef,\n    c: StateContext\n  }, children)));\n};\n\nconst atomToPrintable = atom => atom.debugLabel || atom.toString();\n\nconst isAtom = x => typeof x !== 'symbol';\n\nconst stateToPrintable = state => Object.fromEntries(Array.from(state.m.entries()).map(([atom, [dependents]]) => {\n  const atomState = state.a.get(atom) || {};\n  return [atomToPrintable(atom), {\n    value: atomState.re || atomState.rp || atomState.wp || atomState.v,\n    dependents: Array.from(dependents).filter(isAtom).map(atomToPrintable)\n  }];\n}));\n\nconst useDebugState = state => {\n  useDebugValue(state, stateToPrintable);\n};\n\nlet keyCount = 0; // global key count for all atoms\n\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = get => get(config);\n\n    config.write = (get, set, update) => {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nfunction assertContextValue(x, scope) {\n  if (!x) {\n    throw new Error(`Please use <Provider${scope ? ` scope=${String(scope)}` : ''}>`);\n  }\n}\n\nconst isWritable = atom => !!atom.write;\n\nfunction useAtom(atom) {\n  const [ActionsContext, StateContext] = getContexts(atom.scope);\n  const actions = useContext(ActionsContext);\n  assertContextValue(actions, atom.scope);\n  const value = useContextSelector(StateContext, useCallback(state => {\n    assertContextValue(state);\n    const atomState = actions.read(state, atom);\n\n    if (atomState.re) {\n      throw atomState.re; // read error\n    }\n\n    if (atomState.rp) {\n      throw atomState.rp; // read promise\n    }\n\n    if (atomState.wp) {\n      throw atomState.wp; // write promise\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [atom, actions]));\n  useEffect(() => {\n    const id = Symbol();\n    actions.add(atom, id);\n    return () => {\n      actions.del(atom, id);\n    };\n  }, [actions, atom]);\n  const setAtom = useCallback(update => {\n    if (isWritable(atom)) {\n      return actions.write(atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [atom, actions]);\n  useDebugValue(value);\n  return [value, setAtom];\n}\n\nconst useBridge = scope => {\n  const [ActionsContext, StateContext] = getContexts(scope);\n  const actions = useBridgeValue(ActionsContext);\n  const state = useBridgeValue(StateContext);\n  return useMemo(() => [actions, state], [actions, state]);\n};\nconst Bridge = ({\n  value,\n  scope,\n  children\n}) => {\n  const [actions, state] = value;\n  const [ActionsContext, StateContext] = getContexts(scope);\n  return createElement(BridgeProvider, {\n    context: ActionsContext,\n    value: actions\n  }, createElement(BridgeProvider, {\n    context: StateContext,\n    value: state\n  }, children));\n};\n\nexport { Bridge, Provider, atom, useAtom, useBridge };\n"]},"metadata":{},"sourceType":"module"}